{"ast":null,"code":"'use client';\n\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport classNames from 'classnames';\nimport ResizeObserver from 'rc-resize-observer';\nimport omit from \"rc-util/es/omit\";\nimport React, { createRef, forwardRef, useContext } from 'react';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext } from '../config-provider';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nconst TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\nlet InternalAffix = /*#__PURE__*/function (_React$Component) {\n  _inherits(InternalAffix, _React$Component);\n  var _super = _createSuper(InternalAffix);\n  function InternalAffix() {\n    var _this;\n    _classCallCheck(this, InternalAffix);\n    _this = _super.apply(this, arguments);\n    _this.state = {\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null\n    };\n    _this.placeholderNodeRef = /*#__PURE__*/createRef();\n    _this.fixedNodeRef = /*#__PURE__*/createRef();\n    _this.addListeners = () => {\n      const targetFunc = _this.getTargetFunc();\n      const target = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n      const {\n        prevTarget\n      } = _this.state;\n      if (prevTarget !== target) {\n        TRIGGER_EVENTS.forEach(eventName => {\n          prevTarget === null || prevTarget === void 0 ? void 0 : prevTarget.removeEventListener(eventName, _this.lazyUpdatePosition);\n          target === null || target === void 0 ? void 0 : target.addEventListener(eventName, _this.lazyUpdatePosition);\n        });\n        _this.updatePosition();\n        _this.setState({\n          prevTarget: target\n        });\n      }\n    };\n    _this.removeListeners = () => {\n      if (_this.timer) {\n        clearTimeout(_this.timer);\n        _this.timer = null;\n      }\n      const {\n        prevTarget\n      } = _this.state;\n      const targetFunc = _this.getTargetFunc();\n      const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n      TRIGGER_EVENTS.forEach(eventName => {\n        newTarget === null || newTarget === void 0 ? void 0 : newTarget.removeEventListener(eventName, _this.lazyUpdatePosition);\n        prevTarget === null || prevTarget === void 0 ? void 0 : prevTarget.removeEventListener(eventName, _this.lazyUpdatePosition);\n      });\n      _this.updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      _this.lazyUpdatePosition.cancel();\n    };\n    _this.getOffsetTop = () => {\n      const {\n        offsetBottom,\n        offsetTop\n      } = _this.props;\n      return offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\n    };\n    _this.getOffsetBottom = () => _this.props.offsetBottom;\n    // =================== Measure ===================\n    _this.measure = () => {\n      const {\n        status,\n        lastAffix\n      } = _this.state;\n      const {\n        onChange\n      } = _this.props;\n      const targetFunc = _this.getTargetFunc();\n      if (status !== AffixStatus.Prepare || !_this.fixedNodeRef.current || !_this.placeholderNodeRef.current || !targetFunc) {\n        return;\n      }\n      const offsetTop = _this.getOffsetTop();\n      const offsetBottom = _this.getOffsetBottom();\n      const targetNode = targetFunc();\n      if (targetNode) {\n        const newState = {\n          status: AffixStatus.None\n        };\n        const placeholderRect = getTargetRect(_this.placeholderNodeRef.current);\n        if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n          return;\n        }\n        const targetRect = getTargetRect(targetNode);\n        const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop);\n        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n        if (fixedTop !== undefined) {\n          newState.affixStyle = {\n            position: 'fixed',\n            top: fixedTop,\n            width: placeholderRect.width,\n            height: placeholderRect.height\n          };\n          newState.placeholderStyle = {\n            width: placeholderRect.width,\n            height: placeholderRect.height\n          };\n        } else if (fixedBottom !== undefined) {\n          newState.affixStyle = {\n            position: 'fixed',\n            bottom: fixedBottom,\n            width: placeholderRect.width,\n            height: placeholderRect.height\n          };\n          newState.placeholderStyle = {\n            width: placeholderRect.width,\n            height: placeholderRect.height\n          };\n        }\n        newState.lastAffix = !!newState.affixStyle;\n        if (onChange && lastAffix !== newState.lastAffix) {\n          onChange(newState.lastAffix);\n        }\n        _this.setState(newState);\n      }\n    };\n    _this.prepareMeasure = () => {\n      // event param is used before. Keep compatible ts define here.\n      _this.setState({\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        const {\n          onTestUpdatePosition\n        } = _this.props;\n        onTestUpdatePosition === null || onTestUpdatePosition === void 0 ? void 0 : onTestUpdatePosition();\n      }\n    };\n    _this.updatePosition = throttleByAnimationFrame(() => {\n      _this.prepareMeasure();\n    });\n    _this.lazyUpdatePosition = throttleByAnimationFrame(() => {\n      const targetFunc = _this.getTargetFunc();\n      const {\n        affixStyle\n      } = _this.state;\n      // Check position change before measure to make Safari smooth\n      if (targetFunc && affixStyle) {\n        const offsetTop = _this.getOffsetTop();\n        const offsetBottom = _this.getOffsetBottom();\n        const targetNode = targetFunc();\n        if (targetNode && _this.placeholderNodeRef.current) {\n          const targetRect = getTargetRect(targetNode);\n          const placeholderRect = getTargetRect(_this.placeholderNodeRef.current);\n          const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop);\n          const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      _this.prepareMeasure();\n    });\n    return _this;\n  }\n  _createClass(InternalAffix, [{\n    key: \"getTargetFunc\",\n    value: function getTargetFunc() {\n      const {\n        getTargetContainer\n      } = this.context;\n      const {\n        target\n      } = this.props;\n      if (target !== undefined) {\n        return target;\n      }\n      return getTargetContainer !== null && getTargetContainer !== void 0 ? getTargetContainer : getDefaultTarget;\n    }\n    // Event handler\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // [Legacy] Wait for parent component ref has its value.\n      // We should use target as directly element instead of function which makes element check hard.\n      this.timer = setTimeout(this.addListeners);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      this.addListeners();\n      if (prevProps.offsetTop !== this.props.offsetTop || prevProps.offsetBottom !== this.props.offsetBottom) {\n        this.updatePosition();\n      }\n      this.measure();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.removeListeners();\n    }\n    // =================== Render ===================\n  }, {\n    key: \"render\",\n    value: function render() {\n      const {\n        affixStyle,\n        placeholderStyle\n      } = this.state;\n      const {\n        affixPrefixCls,\n        rootClassName,\n        children\n      } = this.props;\n      const className = classNames(affixStyle && rootClassName, {\n        [affixPrefixCls]: !!affixStyle\n      });\n      let props = omit(this.props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'affixPrefixCls', 'rootClassName']);\n      // Omit this since `onTestUpdatePosition` only works on test.\n      if (process.env.NODE_ENV === 'test') {\n        props = omit(props, ['onTestUpdatePosition']);\n      }\n      return /*#__PURE__*/React.createElement(ResizeObserver, {\n        onResize: this.updatePosition\n      }, /*#__PURE__*/React.createElement(\"div\", Object.assign({}, props, {\n        ref: this.placeholderNodeRef\n      }), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n        style: placeholderStyle,\n        \"aria-hidden\": \"true\"\n      }), /*#__PURE__*/React.createElement(\"div\", {\n        className: className,\n        ref: this.fixedNodeRef,\n        style: affixStyle\n      }, /*#__PURE__*/React.createElement(ResizeObserver, {\n        onResize: this.updatePosition\n      }, children))));\n    }\n  }]);\n  return InternalAffix;\n}(React.Component);\nInternalAffix.contextType = ConfigContext;\nconst Affix = /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    prefixCls: customizePrefixCls,\n    rootClassName\n  } = props;\n  const {\n    getPrefixCls\n  } = useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', customizePrefixCls);\n  const [wrapSSR, hashId] = useStyle(affixPrefixCls);\n  const AffixProps = Object.assign(Object.assign({}, props), {\n    affixPrefixCls,\n    rootClassName: classNames(rootClassName, hashId)\n  });\n  return wrapSSR( /*#__PURE__*/React.createElement(InternalAffix, Object.assign({}, AffixProps, {\n    ref: ref\n  })));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\nexport default Affix;","map":{"version":3,"names":["_classCallCheck","_createClass","_inherits","_createSuper","classNames","ResizeObserver","omit","React","createRef","forwardRef","useContext","throttleByAnimationFrame","ConfigContext","useStyle","getFixedBottom","getFixedTop","getTargetRect","TRIGGER_EVENTS","getDefaultTarget","window","AffixStatus","InternalAffix","_React$Component","_super","_this","apply","arguments","state","status","None","lastAffix","prevTarget","placeholderNodeRef","fixedNodeRef","addListeners","targetFunc","getTargetFunc","target","forEach","eventName","removeEventListener","lazyUpdatePosition","addEventListener","updatePosition","setState","removeListeners","timer","clearTimeout","newTarget","cancel","getOffsetTop","offsetBottom","offsetTop","props","undefined","getOffsetBottom","measure","onChange","Prepare","current","targetNode","newState","placeholderRect","top","left","width","height","targetRect","fixedTop","fixedBottom","affixStyle","position","placeholderStyle","bottom","prepareMeasure","process","env","NODE_ENV","onTestUpdatePosition","key","value","getTargetContainer","context","componentDidMount","setTimeout","componentDidUpdate","prevProps","componentWillUnmount","render","affixPrefixCls","rootClassName","children","className","createElement","onResize","Object","assign","ref","style","Component","contextType","Affix","prefixCls","customizePrefixCls","getPrefixCls","wrapSSR","hashId","AffixProps","displayName"],"sources":["/Users/hamsterpapa/Desktop/ENS/Wallet-browser-extension/mwallet/node_modules/antd/es/affix/index.js"],"sourcesContent":["'use client';\n\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport classNames from 'classnames';\nimport ResizeObserver from 'rc-resize-observer';\nimport omit from \"rc-util/es/omit\";\nimport React, { createRef, forwardRef, useContext } from 'react';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext } from '../config-provider';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nconst TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\nlet InternalAffix = /*#__PURE__*/function (_React$Component) {\n  _inherits(InternalAffix, _React$Component);\n  var _super = _createSuper(InternalAffix);\n  function InternalAffix() {\n    var _this;\n    _classCallCheck(this, InternalAffix);\n    _this = _super.apply(this, arguments);\n    _this.state = {\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null\n    };\n    _this.placeholderNodeRef = /*#__PURE__*/createRef();\n    _this.fixedNodeRef = /*#__PURE__*/createRef();\n    _this.addListeners = () => {\n      const targetFunc = _this.getTargetFunc();\n      const target = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n      const {\n        prevTarget\n      } = _this.state;\n      if (prevTarget !== target) {\n        TRIGGER_EVENTS.forEach(eventName => {\n          prevTarget === null || prevTarget === void 0 ? void 0 : prevTarget.removeEventListener(eventName, _this.lazyUpdatePosition);\n          target === null || target === void 0 ? void 0 : target.addEventListener(eventName, _this.lazyUpdatePosition);\n        });\n        _this.updatePosition();\n        _this.setState({\n          prevTarget: target\n        });\n      }\n    };\n    _this.removeListeners = () => {\n      if (_this.timer) {\n        clearTimeout(_this.timer);\n        _this.timer = null;\n      }\n      const {\n        prevTarget\n      } = _this.state;\n      const targetFunc = _this.getTargetFunc();\n      const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n      TRIGGER_EVENTS.forEach(eventName => {\n        newTarget === null || newTarget === void 0 ? void 0 : newTarget.removeEventListener(eventName, _this.lazyUpdatePosition);\n        prevTarget === null || prevTarget === void 0 ? void 0 : prevTarget.removeEventListener(eventName, _this.lazyUpdatePosition);\n      });\n      _this.updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      _this.lazyUpdatePosition.cancel();\n    };\n    _this.getOffsetTop = () => {\n      const {\n        offsetBottom,\n        offsetTop\n      } = _this.props;\n      return offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\n    };\n    _this.getOffsetBottom = () => _this.props.offsetBottom;\n    // =================== Measure ===================\n    _this.measure = () => {\n      const {\n        status,\n        lastAffix\n      } = _this.state;\n      const {\n        onChange\n      } = _this.props;\n      const targetFunc = _this.getTargetFunc();\n      if (status !== AffixStatus.Prepare || !_this.fixedNodeRef.current || !_this.placeholderNodeRef.current || !targetFunc) {\n        return;\n      }\n      const offsetTop = _this.getOffsetTop();\n      const offsetBottom = _this.getOffsetBottom();\n      const targetNode = targetFunc();\n      if (targetNode) {\n        const newState = {\n          status: AffixStatus.None\n        };\n        const placeholderRect = getTargetRect(_this.placeholderNodeRef.current);\n        if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n          return;\n        }\n        const targetRect = getTargetRect(targetNode);\n        const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop);\n        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n        if (fixedTop !== undefined) {\n          newState.affixStyle = {\n            position: 'fixed',\n            top: fixedTop,\n            width: placeholderRect.width,\n            height: placeholderRect.height\n          };\n          newState.placeholderStyle = {\n            width: placeholderRect.width,\n            height: placeholderRect.height\n          };\n        } else if (fixedBottom !== undefined) {\n          newState.affixStyle = {\n            position: 'fixed',\n            bottom: fixedBottom,\n            width: placeholderRect.width,\n            height: placeholderRect.height\n          };\n          newState.placeholderStyle = {\n            width: placeholderRect.width,\n            height: placeholderRect.height\n          };\n        }\n        newState.lastAffix = !!newState.affixStyle;\n        if (onChange && lastAffix !== newState.lastAffix) {\n          onChange(newState.lastAffix);\n        }\n        _this.setState(newState);\n      }\n    };\n    _this.prepareMeasure = () => {\n      // event param is used before. Keep compatible ts define here.\n      _this.setState({\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        const {\n          onTestUpdatePosition\n        } = _this.props;\n        onTestUpdatePosition === null || onTestUpdatePosition === void 0 ? void 0 : onTestUpdatePosition();\n      }\n    };\n    _this.updatePosition = throttleByAnimationFrame(() => {\n      _this.prepareMeasure();\n    });\n    _this.lazyUpdatePosition = throttleByAnimationFrame(() => {\n      const targetFunc = _this.getTargetFunc();\n      const {\n        affixStyle\n      } = _this.state;\n      // Check position change before measure to make Safari smooth\n      if (targetFunc && affixStyle) {\n        const offsetTop = _this.getOffsetTop();\n        const offsetBottom = _this.getOffsetBottom();\n        const targetNode = targetFunc();\n        if (targetNode && _this.placeholderNodeRef.current) {\n          const targetRect = getTargetRect(targetNode);\n          const placeholderRect = getTargetRect(_this.placeholderNodeRef.current);\n          const fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop);\n          const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      _this.prepareMeasure();\n    });\n    return _this;\n  }\n  _createClass(InternalAffix, [{\n    key: \"getTargetFunc\",\n    value: function getTargetFunc() {\n      const {\n        getTargetContainer\n      } = this.context;\n      const {\n        target\n      } = this.props;\n      if (target !== undefined) {\n        return target;\n      }\n      return getTargetContainer !== null && getTargetContainer !== void 0 ? getTargetContainer : getDefaultTarget;\n    }\n    // Event handler\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // [Legacy] Wait for parent component ref has its value.\n      // We should use target as directly element instead of function which makes element check hard.\n      this.timer = setTimeout(this.addListeners);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      this.addListeners();\n      if (prevProps.offsetTop !== this.props.offsetTop || prevProps.offsetBottom !== this.props.offsetBottom) {\n        this.updatePosition();\n      }\n      this.measure();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.removeListeners();\n    }\n    // =================== Render ===================\n  }, {\n    key: \"render\",\n    value: function render() {\n      const {\n        affixStyle,\n        placeholderStyle\n      } = this.state;\n      const {\n        affixPrefixCls,\n        rootClassName,\n        children\n      } = this.props;\n      const className = classNames(affixStyle && rootClassName, {\n        [affixPrefixCls]: !!affixStyle\n      });\n      let props = omit(this.props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'affixPrefixCls', 'rootClassName']);\n      // Omit this since `onTestUpdatePosition` only works on test.\n      if (process.env.NODE_ENV === 'test') {\n        props = omit(props, ['onTestUpdatePosition']);\n      }\n      return /*#__PURE__*/React.createElement(ResizeObserver, {\n        onResize: this.updatePosition\n      }, /*#__PURE__*/React.createElement(\"div\", Object.assign({}, props, {\n        ref: this.placeholderNodeRef\n      }), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n        style: placeholderStyle,\n        \"aria-hidden\": \"true\"\n      }), /*#__PURE__*/React.createElement(\"div\", {\n        className: className,\n        ref: this.fixedNodeRef,\n        style: affixStyle\n      }, /*#__PURE__*/React.createElement(ResizeObserver, {\n        onResize: this.updatePosition\n      }, children))));\n    }\n  }]);\n  return InternalAffix;\n}(React.Component);\nInternalAffix.contextType = ConfigContext;\nconst Affix = /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    prefixCls: customizePrefixCls,\n    rootClassName\n  } = props;\n  const {\n    getPrefixCls\n  } = useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', customizePrefixCls);\n  const [wrapSSR, hashId] = useStyle(affixPrefixCls);\n  const AffixProps = Object.assign(Object.assign({}, props), {\n    affixPrefixCls,\n    rootClassName: classNames(rootClassName, hashId)\n  });\n  return wrapSSR( /*#__PURE__*/React.createElement(InternalAffix, Object.assign({}, AffixProps, {\n    ref: ref\n  })));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\nexport default Affix;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}