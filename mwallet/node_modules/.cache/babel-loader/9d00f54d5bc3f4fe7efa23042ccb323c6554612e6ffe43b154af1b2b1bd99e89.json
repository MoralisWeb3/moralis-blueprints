{"ast":null,"code":"function decode_arithmetic(bytes) {\n  let pos = 0;\n  function u16() {\n    return bytes[pos++] << 8 | bytes[pos++];\n  }\n\n  // decode the frequency table\n  let symbol_count = u16();\n  let total = 1;\n  let acc = [0, 1]; // first symbol has frequency 1\n  for (let i = 1; i < symbol_count; i++) {\n    acc.push(total += u16());\n  }\n\n  // skip the sized-payload that the last 3 symbols index into\n  let skip = u16();\n  let pos_payload = pos;\n  pos += skip;\n  let read_width = 0;\n  let read_buffer = 0;\n  function read_bit() {\n    if (read_width == 0) {\n      // this will read beyond end of buffer\n      // but (undefined|0) => zero pad\n      read_buffer = read_buffer << 8 | bytes[pos++];\n      read_width = 8;\n    }\n    return read_buffer >> --read_width & 1;\n  }\n  const N = 31;\n  const FULL = 2 ** N;\n  const HALF = FULL >>> 1;\n  const QRTR = HALF >> 1;\n  const MASK = FULL - 1;\n\n  // fill register\n  let register = 0;\n  for (let i = 0; i < N; i++) register = register << 1 | read_bit();\n  let symbols = [];\n  let low = 0;\n  let range = FULL; // treat like a float\n  while (true) {\n    let value = Math.floor(((register - low + 1) * total - 1) / range);\n    let start = 0;\n    let end = symbol_count;\n    while (end - start > 1) {\n      // binary search\n      let mid = start + end >>> 1;\n      if (value < acc[mid]) {\n        end = mid;\n      } else {\n        start = mid;\n      }\n    }\n    if (start == 0) break; // first symbol is end mark\n    symbols.push(start);\n    let a = low + Math.floor(range * acc[start] / total);\n    let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n    while (((a ^ b) & HALF) == 0) {\n      register = register << 1 & MASK | read_bit();\n      a = a << 1 & MASK;\n      b = b << 1 & MASK | 1;\n    }\n    while (a & ~b & QRTR) {\n      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n      a = a << 1 ^ HALF;\n      b = (b ^ HALF) << 1 | HALF | 1;\n    }\n    low = a;\n    range = 1 + b - a;\n  }\n  let offset = symbol_count - 4;\n  return symbols.map(x => {\n    // index into payload\n    switch (x - offset) {\n      case 3:\n        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 2:\n        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 1:\n        return offset + bytes[pos_payload++];\n      default:\n        return x - 1;\n    }\n  });\n}\n\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n  let pos = 0;\n  return () => v[pos++];\n}\nfunction read_compressed_payload(s) {\n  return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \nfunction unsafe_atob(s) {\n  let lookup = [];\n  [...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\n  let n = s.length;\n  let ret = new Uint8Array(6 * n >> 3);\n  for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\n    carry = carry << 6 | lookup[s.charCodeAt(i)];\n    width += 6;\n    if (width >= 8) {\n      ret[pos++] = carry >> (width -= 8);\n    }\n  }\n  return ret;\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n  return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n  let v = Array(n);\n  for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n  return v;\n}\n\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next, prev = 0) {\n  let ret = [];\n  while (true) {\n    let x = next();\n    let n = next();\n    if (!n) break;\n    prev += x;\n    for (let i = 0; i < n; i++) {\n      ret.push(prev + i);\n    }\n    prev += n + 1;\n  }\n  return ret;\n}\nfunction read_sorted_arrays(next) {\n  return read_array_while(() => {\n    let v = read_sorted(next);\n    if (v.length) return v;\n  });\n}\n\n// returns map of x => ys\nfunction read_mapped(next) {\n  let ret = [];\n  while (true) {\n    let w = next();\n    if (w == 0) break;\n    ret.push(read_linear_table(w, next));\n  }\n  while (true) {\n    let w = next() - 1;\n    if (w < 0) break;\n    ret.push(read_replacement_table(w, next));\n  }\n  return ret.flat();\n}\n\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n  let v = [];\n  while (true) {\n    let x = next(v.length);\n    if (!x) break;\n    v.push(x);\n  }\n  return v;\n}\n\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n  let m = Array(n).fill().map(() => []);\n  for (let i = 0; i < w; i++) {\n    read_deltas(n, next).forEach((x, j) => m[j].push(x));\n  }\n  return m;\n}\n\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n  let dx = 1 + next();\n  let dy = next();\n  let vN = read_array_while(next);\n  let m = read_transposed(vN.length, 1 + w, next);\n  return m.flatMap((v, i) => {\n    let [x, ...ys] = v;\n    return Array(vN[i]).fill().map((_, j) => {\n      let j_dy = j * dy;\n      return [x + j * dx, ys.map(y => y + j_dy)];\n    });\n  });\n}\n\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n  let n = 1 + next();\n  let m = read_transposed(n, 1 + w, next);\n  return m.map(v => [v[0], v.slice(1)]);\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r$1 = read_compressed_payload('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');\nconst FENCED = new Map([[8217, \"apostrophe\"], [8260, \"fraction slash\"], [12539, \"middle dot\"]]);\nconst NSM_MAX = 4;\nfunction hex_cp(cp) {\n  return cp.toString(16).toUpperCase().padStart(2, '0');\n}\nfunction quote_cp(cp) {\n  return `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\nfunction explode_cp(s) {\n  // this is about 2x faster\n  let cps = [];\n  for (let pos = 0, len = s.length; pos < len;) {\n    let cp = s.codePointAt(pos);\n    pos += cp < 0x10000 ? 1 : 2;\n    cps.push(cp);\n  }\n  return cps;\n}\nfunction str_from_cps(cps) {\n  const chunk = 4096;\n  let len = cps.length;\n  if (len < chunk) return String.fromCodePoint(...cps);\n  let buf = [];\n  for (let i = 0; i < len;) {\n    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n  }\n  return buf.join('');\n}\nfunction compare_arrays(a, b) {\n  let n = a.length;\n  let c = n - b.length;\n  for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\n  return c;\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r = read_compressed_payload('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');\n\n// https://unicode.org/reports/tr15/\n\nfunction unpack_cc(packed) {\n  return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n  return packed & 0xFFFFFF;\n}\nconst SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, i + 1 << 24]))); // pre-shifted\nconst EXCLUSIONS = new Set(read_sorted(r));\nconst DECOMP = new Map();\nconst RECOMP = new Map();\nfor (let [cp, cps] of read_mapped(r)) {\n  if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n    let [a, b] = cps;\n    let bucket = RECOMP.get(a);\n    if (!bucket) {\n      bucket = new Map();\n      RECOMP.set(a, bucket);\n    }\n    bucket.set(b, cp);\n  }\n  DECOMP.set(cp, cps.reverse()); // stored reversed\n}\n\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nconst S0 = 0xAC00;\nconst L0 = 0x1100;\nconst V0 = 0x1161;\nconst T0 = 0x11A7;\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst N_COUNT = V_COUNT * T_COUNT;\nconst S_COUNT = L_COUNT * N_COUNT;\nconst S1 = S0 + S_COUNT;\nconst L1 = L0 + L_COUNT;\nconst V1 = V0 + V_COUNT;\nconst T1 = T0 + T_COUNT;\nfunction is_hangul(cp) {\n  return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n  if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n    return a + (b - T0);\n  } else {\n    let recomp = RECOMP.get(a);\n    if (recomp) {\n      recomp = recomp.get(b);\n      if (recomp) {\n        return recomp;\n      }\n    }\n    return -1;\n  }\n}\nfunction decomposed(cps) {\n  let ret = [];\n  let buf = [];\n  let check_order = false;\n  function add(cp) {\n    let cc = SHIFTED_RANK.get(cp);\n    if (cc) {\n      check_order = true;\n      cp |= cc;\n    }\n    ret.push(cp);\n  }\n  for (let cp of cps) {\n    while (true) {\n      if (cp < 0x80) {\n        ret.push(cp);\n      } else if (is_hangul(cp)) {\n        let s_index = cp - S0;\n        let l_index = s_index / N_COUNT | 0;\n        let v_index = s_index % N_COUNT / T_COUNT | 0;\n        let t_index = s_index % T_COUNT;\n        add(L0 + l_index);\n        add(V0 + v_index);\n        if (t_index > 0) add(T0 + t_index);\n      } else {\n        let mapped = DECOMP.get(cp);\n        if (mapped) {\n          buf.push(...mapped);\n        } else {\n          add(cp);\n        }\n      }\n      if (!buf.length) break;\n      cp = buf.pop();\n    }\n  }\n  if (check_order && ret.length > 1) {\n    let prev_cc = unpack_cc(ret[0]);\n    for (let i = 1; i < ret.length; i++) {\n      let cc = unpack_cc(ret[i]);\n      if (cc == 0 || prev_cc <= cc) {\n        prev_cc = cc;\n        continue;\n      }\n      let j = i - 1;\n      while (true) {\n        let tmp = ret[j + 1];\n        ret[j + 1] = ret[j];\n        ret[j] = tmp;\n        if (!j) break;\n        prev_cc = unpack_cc(ret[--j]);\n        if (prev_cc <= cc) break;\n      }\n      prev_cc = unpack_cc(ret[i]);\n    }\n  }\n  return ret;\n}\nfunction composed_from_decomposed(v) {\n  let ret = [];\n  let stack = [];\n  let prev_cp = -1;\n  let prev_cc = 0;\n  for (let packed of v) {\n    let cc = unpack_cc(packed);\n    let cp = unpack_cp(packed);\n    if (prev_cp == -1) {\n      if (cc == 0) {\n        prev_cp = cp;\n      } else {\n        ret.push(cp);\n      }\n    } else if (prev_cc > 0 && prev_cc >= cc) {\n      if (cc == 0) {\n        ret.push(prev_cp, ...stack);\n        stack.length = 0;\n        prev_cp = cp;\n      } else {\n        stack.push(cp);\n      }\n      prev_cc = cc;\n    } else {\n      let composed = compose_pair(prev_cp, cp);\n      if (composed >= 0) {\n        prev_cp = composed;\n      } else if (prev_cc == 0 && cc == 0) {\n        ret.push(prev_cp);\n        prev_cp = cp;\n      } else {\n        stack.push(cp);\n        prev_cc = cc;\n      }\n    }\n  }\n  if (prev_cp >= 0) {\n    ret.push(prev_cp, ...stack);\n  }\n  return ret;\n}\n\n// note: cps can be iterable\nfunction nfd(cps) {\n  return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n  return composed_from_decomposed(decomposed(cps));\n}\n\n//const t0 = performance.now();\n\nconst STOP = 0x2E;\nconst FE0F = 0xFE0F;\nconst STOP_CH = '.';\nconst UNIQUE_PH = 1;\nconst HYPHEN = 0x2D;\nfunction read_set() {\n  return new Set(read_sorted(r$1));\n}\nconst MAPPED = new Map(read_mapped(r$1));\nconst IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\n// 20230217: we still need all CM for proper error formatting\n// but norm only needs NSM subset that are potentially-valid\nconst CM = read_set();\nconst NSM = new Set(read_sorted(r$1).map(function (i) {\n  return this[i];\n}, [...CM]));\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/\nconst ESCAPE = read_set(); // characters that should not be printed\nconst NFC_CHECK = read_set();\nconst CHUNKS = read_sorted_arrays(r$1);\nfunction read_chunked() {\n  // deduplicated sets + uniques\n  return new Set([read_sorted(r$1).map(i => CHUNKS[i]), read_sorted(r$1)].flat(2));\n}\nconst UNRESTRICTED = r$1();\nconst GROUPS = read_array_while(i => {\n  // minifier property mangling seems unsafe\n  // so these are manually renamed to single chars\n  let N = read_array_while(r$1).map(x => x + 0x60);\n  if (N.length) {\n    let R = i >= UNRESTRICTED; // first arent restricted\n    N[0] -= 32; // capitalize\n    N = str_from_cps(N);\n    if (R) N = `Restricted[${N}]`;\n    let P = read_chunked(); // primary\n    let Q = read_chunked(); // secondary\n    let V = [...P, ...Q].sort((a, b) => a - b); // derive: sorted valid\n    //let M = r()-1; // combining mark\n    let M = !r$1(); // not-whitelisted, check for NSM\n    // code currently isn't needed\n    /*if (M < 0) { // whitelisted\r\n    \tM = new Map(read_array_while(() => {\r\n    \t\tlet i = r();\r\n    \t\tif (i) return [V[i-1], read_array_while(() => {\r\n    \t\t\tlet v = read_array_while(r);\r\n    \t\t\tif (v.length) return v.map(x => x-1);\r\n    \t\t})];\r\n    \t}));\r\n    }*/\n    return {\n      N,\n      P,\n      M,\n      R,\n      V: new Set(V)\n    };\n  }\n});\nconst WHOLE_VALID = read_set();\nconst WHOLE_MAP = new Map();\n// decode compressed wholes\n[...WHOLE_VALID, ...read_set()].sort((a, b) => a - b).map((cp, i, v) => {\n  let d = r$1();\n  let w = v[i] = d ? v[i - d] : {\n    V: [],\n    M: new Map()\n  };\n  w.V.push(cp); // add to member set\n  if (!WHOLE_VALID.has(cp)) {\n    WHOLE_MAP.set(cp, w); // register with whole map\n  }\n});\n// compute confusable-extent complements\nfor (let {\n  V,\n  M\n} of new Set(WHOLE_MAP.values())) {\n  // connect all groups that have each whole character\n  let recs = [];\n  for (let cp of V) {\n    let gs = GROUPS.filter(g => g.V.has(cp));\n    let rec = recs.find(({\n      G\n    }) => gs.some(g => G.has(g)));\n    if (!rec) {\n      rec = {\n        G: new Set(),\n        V: []\n      };\n      recs.push(rec);\n    }\n    rec.V.push(cp);\n    gs.forEach(g => rec.G.add(g));\n  }\n  // per character cache groups which are not a member of the extent\n  let union = recs.flatMap(({\n    G\n  }) => [...G]);\n  for (let {\n    G,\n    V\n  } of recs) {\n    let complement = new Set(union.filter(g => !G.has(g)));\n    for (let cp of V) {\n      M.set(cp, complement);\n    }\n  }\n}\nlet union = new Set(); // exists in 1+ groups\nlet multi = new Set(); // exists in 2+ groups\nfor (let g of GROUPS) {\n  for (let cp of g.V) {\n    (union.has(cp) ? multi : union).add(cp);\n  }\n}\n// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\nfor (let cp of union) {\n  if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n    WHOLE_MAP.set(cp, UNIQUE_PH);\n  }\n}\nconst VALID = new Set([...union, ...nfd(union)]); // possibly valid\n\n// decode emoji\nconst EMOJI_SORTED = read_sorted(r$1); // temporary\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\nconst EMOJI_ROOT = read_emoji_trie([]);\nfunction read_emoji_trie(cps) {\n  let B = read_array_while(() => {\n    let keys = read_sorted(r$1).map(i => EMOJI_SORTED[i]);\n    if (keys.length) return read_emoji_trie(keys);\n  }).sort((a, b) => b.Q.size - a.Q.size); // sort by likelihood\n  let temp = r$1();\n  let V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\n  temp = temp / 3 | 0;\n  let F = temp & 1; // allow FE0F\n  temp >>= 1;\n  let S = temp & 1; // save\n  let C = temp & 2; // check\n  return {\n    B,\n    V,\n    F,\n    S,\n    C,\n    Q: new Set(cps)\n  };\n}\n//console.log(performance.now() - t0);\n\n// free tagging system\nclass Emoji extends Array {\n  get is_emoji() {\n    return true;\n  }\n}\n\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\n  //if (Number.isInteger(cps)) cps = [cps];\n  //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n  let buf = [];\n  if (is_combining_mark(cps[0])) buf.push('◌');\n  let prev = 0;\n  let n = cps.length;\n  for (let i = 0; i < n; i++) {\n    let cp = cps[i];\n    if (should_escape(cp)) {\n      buf.push(str_from_cps(cps.slice(prev, i)));\n      buf.push(quoter(cp));\n      prev = i + 1;\n    }\n  }\n  buf.push(str_from_cps(cps.slice(prev, n)));\n  return buf.join('');\n}\n\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n  return (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\n}\n\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n  return `\"${s}\"\\u200E`; // strong LTR\n}\n\nfunction check_label_extension(cps) {\n  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n    throw new Error('invalid label extension');\n  }\n}\nfunction check_leading_underscore(cps) {\n  const UNDERSCORE = 0x5F;\n  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0;) {\n    if (cps[--i] !== UNDERSCORE) {\n      throw new Error('underscore allowed only at start');\n    }\n  }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n  let cp = cps[0];\n  let prev = FENCED.get(cp);\n  if (prev) throw error_placement(`leading ${prev}`);\n  let n = cps.length;\n  let last = -1; // prevents trailing from throwing\n  for (let i = 1; i < n; i++) {\n    cp = cps[i];\n    let match = FENCED.get(cp);\n    if (match) {\n      // since cps[0] isn't fenced, cps[1] cannot throw\n      if (last == i) throw error_placement(`${prev} + ${match}`);\n      last = i + 1;\n      prev = match;\n    }\n  }\n  if (last == n) throw error_placement(`trailing ${prev}`);\n}\n\n// note: set(s) cannot be exposed because they can be modified\nfunction is_combining_mark(cp) {\n  return CM.has(cp);\n}\nfunction should_escape(cp) {\n  return ESCAPE.has(cp);\n}\nfunction ens_normalize_fragment(frag, decompose) {\n  let nf = decompose ? nfd : nfc;\n  return frag.split(STOP_CH).map(label => str_from_cps(process(explode_cp(label), nf).flatMap(x => x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n  return flatten(ens_split(name));\n}\nfunction ens_beautify(name) {\n  let split = ens_split(name, true);\n  // this is experimental\n  for (let {\n    type,\n    output,\n    error\n  } of split) {\n    if (error) continue;\n\n    // replace leading/trailing hyphen\n    // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n    // not exactly the same in every font, but very similar: \"-\" vs \"‐\"\n    /*\r\n    const UNICODE_HYPHEN = 0x2010;\r\n    // maybe this should replace all for visual consistancy?\r\n    // `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n    //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n    if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n    let end = output.length-1;\r\n    if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n    */\n    // 20230123: WHATWG URL uses \"CheckHyphens\" false\n    // https://url.spec.whatwg.org/#idna\n\n    // update ethereum symbol\n    // ξ => Ξ if not greek\n    if (type !== 'Greek') {\n      let prev = 0;\n      while (true) {\n        let next = output.indexOf(0x3BE, prev);\n        if (next < 0) break;\n        output[next] = 0x39E;\n        prev = next + 1;\n      }\n    }\n\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    //output.splice(0, 0, 0x200E);\n  }\n\n  return flatten(split);\n}\nfunction ens_split(name, preserve_emoji) {\n  let offset = 0;\n  // https://unicode.org/reports/tr46/#Validity_Criteria\n  // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n  return name.split(STOP_CH).map(label => {\n    let input = explode_cp(label);\n    let info = {\n      input,\n      offset // codepoint, not substring!\n    };\n\n    offset += input.length + 1; // + stop\n    let norm;\n    try {\n      // 1.) \"The label must be in Unicode Normalization Form NFC\"\n      let tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\n      let token_count = tokens.length;\n      let type;\n      if (!token_count) {\n        // the label was effectively empty (could of had ignored characters)\n        // 20230120: change to strict\n        // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n        //norm = [];\n        //type = 'None'; // use this instead of next match, \"ASCII\"\n        throw new Error(`empty label`);\n      } else {\n        let chars = tokens[0];\n        let emoji = token_count > 1 || chars.is_emoji;\n        if (!emoji && chars.every(cp => cp < 0x80)) {\n          // special case for ascii\n          norm = chars;\n          check_leading_underscore(norm);\n          // only needed for ascii\n          // 20230123: matches matches WHATWG, see note 3.3\n          check_label_extension(norm);\n          // cant have fenced\n          // cant have cm\n          // cant have wholes\n          // see derive: \"Fastpath ASCII\"\n          type = 'ASCII';\n        } else {\n          if (emoji) {\n            // there is at least one emoji\n            info.emoji = true;\n            chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\n          }\n\n          norm = tokens.flatMap(x => !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);\n          check_leading_underscore(norm);\n          if (!chars.length) {\n            // theres no text, just emoji\n            type = 'Emoji';\n          } else {\n            // 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n            if (CM.has(norm[0])) throw error_placement('leading combining mark');\n            for (let i = 1; i < token_count; i++) {\n              // we've already checked the first token\n              let cps = tokens[i];\n              if (!cps.is_emoji && CM.has(cps[0])) {\n                // every text token has emoji neighbors, eg. EtEEEtEt...\n                // bidi_qq() not needed since emoji is LTR and cps is a CM\n                throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}\"`);\n              }\n            }\n            check_fenced(norm);\n            let unique = [...new Set(chars)];\n            let [g] = determine_group(unique); // take the first match\n            // see derive: \"Matching Groups have Same CM Style\"\n            // alternative: could form a hybrid type: Latin/Japanese/...\t\n            check_group(g, chars); // need text in order\n            check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n            type = g.N;\n            // 20230121: consider exposing restricted flag\n            // it's simpler to just check for 'Restricted'\n            // or even better: type.endsWith(']')\n            //if (g.R) info.restricted = true;\n          }\n        }\n      }\n\n      info.type = type;\n    } catch (err) {\n      info.error = err; // use full error object\n    }\n\n    info.output = norm;\n    return info;\n  });\n}\nfunction check_whole(group, unique) {\n  let maker;\n  let shared = []; // TODO: can this be avoided?\n  for (let cp of unique) {\n    let whole = WHOLE_MAP.get(cp);\n    if (whole === UNIQUE_PH) return; // unique, non-confusable\n    if (whole) {\n      let set = whole.M.get(cp); // groups which have a character that look-like this character\n      maker = maker ? maker.filter(g => set.has(g)) : [...set];\n      if (!maker.length) return; // confusable intersection is empty\n    } else {\n      shared.push(cp);\n    }\n  }\n  if (maker) {\n    // we have 1+ confusable\n    // check if any of the remaning groups\n    // contain the shared characters too\n    for (let g of maker) {\n      if (shared.every(cp => g.V.has(cp))) {\n        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);\n      }\n    }\n  }\n}\n\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n  let groups = GROUPS;\n  for (let cp of unique) {\n    // note: we need to dodge CM that are whitelisted\n    // but that code isn't currently necessary\n    let gs = groups.filter(g => g.V.has(cp));\n    if (!gs.length) {\n      if (groups === GROUPS) {\n        // the character was composed of valid parts\n        // but it's NFC form is invalid\n        throw error_disallowed(cp); // this should be rare\n      } else {\n        // there is no group that contains all these characters\n        // throw using the highest priority group that matched\n        // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n        throw error_group_member(groups[0], cp);\n      }\n    }\n    groups = gs;\n    if (gs.length == 1) break; // there is only one group left\n  }\n  // there are at least 1 group(s) with all of these characters\n  return groups;\n}\n\n// throw on first error\nfunction flatten(split) {\n  return split.map(({\n    input,\n    error,\n    output\n  }) => {\n    if (error) {\n      // don't print label again if just a single label\n      let msg = error.message;\n      // bidi_qq() only necessary if msg is digits\n      throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);\n    }\n    return str_from_cps(output);\n  }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n  // TODO: add cp to error?\n  return new Error(`disallowed character: ${quoted_cp(cp)}`);\n}\nfunction error_group_member(g, cp) {\n  let quoted = quoted_cp(cp);\n  let gg = GROUPS.find(g => g.P.has(cp));\n  if (gg) {\n    quoted = `${gg.N} ${quoted}`;\n  }\n  return new Error(`illegal mixture: ${g.N} + ${quoted}`);\n}\nfunction error_placement(where) {\n  return new Error(`illegal placement: ${where}`);\n}\n\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n  let {\n    V,\n    M\n  } = g;\n  for (let cp of cps) {\n    if (!V.has(cp)) {\n      // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n      // at the moment, it's unnecessary to introduce an extra error type\n      // until there exists a whitelisted multi-character\n      //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n      // there are 3 cases:\n      //   1. illegal cm for wrong group => mixture error\n      //   2. illegal cm for same group => cm error\n      //       requires set of whitelist cm per group: \n      //        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\n      //   3. wrong group => mixture error\n      throw error_group_member(g, cp);\n    }\n  }\n  //if (M >= 0) { // we have a known fixed cm count\n  if (M) {\n    // we need to check for NSM\n    let decomposed = nfd(cps);\n    for (let i = 1, e = decomposed.length; i < e; i++) {\n      // see: assumption\n      // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n      /*\r\n      if (CM.has(decomposed[i])) {\r\n      \tlet j = i + 1;\r\n      \twhile (j < e && CM.has(decomposed[j])) j++;\r\n      \tif (j - i > M) {\r\n      \t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n      \t}\r\n      \ti = j;\r\n      }\r\n      */\n      // 20230217: switch to NSM counting\n      // https://www.unicode.org/reports/tr39/#Optional_Detection\n      if (NSM.has(decomposed[i])) {\n        let j = i + 1;\n        for (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\n          // a. Forbid sequences of the same nonspacing mark.\n          for (let k = i; k < j; k++) {\n            // O(n^2) but n < 100\n            if (decomposed[k] == cp) {\n              throw new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);\n            }\n          }\n        }\n        // parse to end so we have full nsm count\n        // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n        if (j - i > NSM_MAX) {\n          // note: this slice starts with a base char or spacing-mark cm\n          throw new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);\n        }\n        i = j;\n      }\n    }\n  }\n  // *** this code currently isn't needed ***\n  /*\r\n  let cm_whitelist = M instanceof Map;\r\n  for (let i = 0, e = cps.length; i < e; ) {\r\n  \tlet cp = cps[i++];\r\n  \tlet seqs = cm_whitelist && M.get(cp);\r\n  \tif (seqs) { \r\n  \t\t// list of codepoints that can follow\r\n  \t\t// if this exists, this will always be 1+\r\n  \t\tlet j = i;\r\n  \t\twhile (j < e && CM.has(cps[j])) j++;\r\n  \t\tlet cms = cps.slice(i, j);\r\n  \t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n  \t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n  \t\ti = j;\r\n  \t} else if (!V.has(cp)) {\r\n  \t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n  \t\tlet quoted = quoted_cp(cp);\r\n  \t\tfor (let cp of cps) {\r\n  \t\t\tlet u = UNIQUE.get(cp);\r\n  \t\t\tif (u && u !== g) {\r\n  \t\t\t\t// if both scripts are restricted this error is confusing\r\n  \t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n  \t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n  \t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n  \t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n  \t}\r\n  }\r\n  if (!cm_whitelist) {\r\n  \tlet decomposed = nfd(cps);\r\n  \tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n  \t\tif (CM.has(decomposed[i])) {\r\n  \t\t\tlet j = i + 1;\r\n  \t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n  \t\t\tif (j - i > M) {\r\n  \t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n  \t\t\t}\r\n  \t\t\ti = j;\r\n  \t\t}\r\n  \t}\r\n  }\r\n  */\n}\n\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\nfunction process(input, nf) {\n  let ret = [];\n  let chars = [];\n  input = input.slice().reverse(); // flip so we can pop\n  while (input.length) {\n    let emoji = consume_emoji_reversed(input);\n    if (emoji) {\n      if (chars.length) {\n        ret.push(nf(chars));\n        chars = [];\n      }\n      ret.push(emoji);\n    } else {\n      let cp = input.pop();\n      if (VALID.has(cp)) {\n        chars.push(cp);\n      } else {\n        let cps = MAPPED.get(cp);\n        if (cps) {\n          chars.push(...cps);\n        } else if (!IGNORED.has(cp)) {\n          throw error_disallowed(cp);\n        }\n      }\n    }\n  }\n  if (chars.length) {\n    ret.push(nf(chars));\n  }\n  return ret;\n}\nfunction filter_fe0f(cps) {\n  return cps.filter(cp => cp != FE0F);\n}\n\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// allows optional FE0F\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n  let node = EMOJI_ROOT;\n  let emoji;\n  let saved;\n  let stack = [];\n  let pos = cps.length;\n  if (eaten) eaten.length = 0; // clear input buffer (if needed)\n  while (pos) {\n    let cp = cps[--pos];\n    node = node.B.find(x => x.Q.has(cp));\n    if (!node) break;\n    if (node.S) {\n      // remember\n      saved = cp;\n    } else if (node.C) {\n      // check exclusion\n      if (cp === saved) break;\n    }\n    stack.push(cp);\n    if (node.F) {\n      stack.push(FE0F);\n      if (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\n    }\n\n    if (node.V) {\n      // this is a valid emoji (so far)\n      emoji = conform_emoji_copy(stack, node);\n      if (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n      cps.length = pos; // truncate\n    }\n  }\n  /*\r\n  // *** this code currently isn't needed ***\r\n  if (!emoji) {\r\n  \tlet cp = cps[cps.length-1];\r\n  \tif (EMOJI_SOLO.has(cp)) {\r\n  \t\tif (eaten) eaten.push(cp);\r\n  \t\temoji = Emoji.of(cp);\r\n  \t\tcps.pop();\r\n  \t}\r\n  }\r\n  */\n  return emoji;\n}\n\n// create a copy and fix any unicode quirks\nfunction conform_emoji_copy(cps, node) {\n  let copy = Emoji.from(cps); // copy stack\n  if (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\n  return copy;\n}\n\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n  // *** this code currently isn't needed ***\n  //let ret = [...EMOJI_SOLO].map(x => [x]);\n  let ret = [];\n  build(EMOJI_ROOT, []);\n  return ret.sort(compare_arrays);\n  function build(node, cps, saved) {\n    if (node.S) {\n      saved = cps[cps.length - 1];\n    } else if (node.C) {\n      if (saved === cps[cps.length - 1]) return;\n    }\n    if (node.F) cps.push(FE0F);\n    if (node.V) ret.push(conform_emoji_copy(cps, node));\n    for (let br of node.B) {\n      for (let cp of br.Q) {\n        build(br, [...cps, cp], saved);\n      }\n    }\n  }\n}\n\n// ************************************************************\n// tokenizer \n\nconst TY_VALID = 'valid';\nconst TY_MAPPED = 'mapped';\nconst TY_IGNORED = 'ignored';\nconst TY_DISALLOWED = 'disallowed';\nconst TY_EMOJI = 'emoji';\nconst TY_NFC = 'nfc';\nconst TY_STOP = 'stop';\nfunction ens_tokenize(name, {\n  nf = true // collapse unnormalized runs into a single token\n} = {}) {\n  let input = explode_cp(name).reverse();\n  let eaten = [];\n  let tokens = [];\n  while (input.length) {\n    let emoji = consume_emoji_reversed(input, eaten);\n    if (emoji) {\n      tokens.push({\n        type: TY_EMOJI,\n        emoji,\n        input: eaten.slice(),\n        cps: filter_fe0f(emoji)\n      });\n    } else {\n      let cp = input.pop();\n      if (cp == STOP) {\n        tokens.push({\n          type: TY_STOP,\n          cp\n        });\n      } else if (VALID.has(cp)) {\n        tokens.push({\n          type: TY_VALID,\n          cps: [cp]\n        });\n      } else if (IGNORED.has(cp)) {\n        tokens.push({\n          type: TY_IGNORED,\n          cp\n        });\n      } else {\n        let cps = MAPPED.get(cp);\n        if (cps) {\n          tokens.push({\n            type: TY_MAPPED,\n            cp,\n            cps: cps.slice()\n          });\n        } else {\n          tokens.push({\n            type: TY_DISALLOWED,\n            cp\n          });\n        }\n      }\n    }\n  }\n  if (nf) {\n    for (let i = 0, start = -1; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (is_valid_or_mapped(token.type)) {\n        if (requires_check(token.cps)) {\n          // normalization might be needed\n          let end = i + 1;\n          for (let pos = end; pos < tokens.length; pos++) {\n            // find adjacent text\n            let {\n              type,\n              cps\n            } = tokens[pos];\n            if (is_valid_or_mapped(type)) {\n              if (!requires_check(cps)) break;\n              end = pos + 1;\n            } else if (type !== TY_IGNORED) {\n              // || type !== TY_DISALLOWED) { \n              break;\n            }\n          }\n          if (start < 0) start = i;\n          let slice = tokens.slice(start, end);\n          let cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n          let cps = nfc(cps0);\n          if (compare_arrays(cps, cps0)) {\n            // bundle into an nfc token\n            tokens.splice(start, end - start, {\n              type: TY_NFC,\n              input: cps0,\n              // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\n              cps,\n              tokens0: collapse_valid_tokens(slice),\n              tokens: ens_tokenize(str_from_cps(cps), {\n                nf: false\n              })\n            });\n            i = start;\n          } else {\n            i = end - 1; // skip to end of slice\n          }\n\n          start = -1; // reset\n        } else {\n          start = i; // remember last\n        }\n      } else if (token.type !== TY_IGNORED) {\n        // 20221024: is this correct?\n        start = -1; // reset\n      }\n    }\n  }\n\n  return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n  return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n  return cps.some(cp => NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n  for (let i = 0; i < tokens.length; i++) {\n    if (tokens[i].type == TY_VALID) {\n      let j = i + 1;\n      while (j < tokens.length && tokens[j].type == TY_VALID) j++;\n      tokens.splice(i, j - i, {\n        type: TY_VALID,\n        cps: tokens.slice(i, j).flatMap(x => x.cps)\n      });\n    }\n  }\n  return tokens;\n}\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };","map":{"version":3,"names":["decode_arithmetic","bytes","pos","u16","symbol_count","total","acc","i","push","skip","pos_payload","read_width","read_buffer","read_bit","N","FULL","HALF","QRTR","MASK","register","symbols","low","range","value","Math","floor","start","end","mid","a","b","offset","map","x","read_payload","v","read_compressed_payload","s","unsafe_atob","lookup","forEach","c","charCodeAt","n","length","ret","Uint8Array","width","carry","signed","read_deltas","next","Array","read_sorted","prev","read_sorted_arrays","read_array_while","read_mapped","w","read_linear_table","read_replacement_table","flat","read_transposed","m","fill","j","dx","dy","vN","flatMap","ys","_","j_dy","y","slice","r$1","FENCED","Map","NSM_MAX","hex_cp","cp","toString","toUpperCase","padStart","quote_cp","explode_cp","cps","len","codePointAt","str_from_cps","chunk","String","fromCodePoint","buf","join","compare_arrays","r","unpack_cc","packed","unpack_cp","SHIFTED_RANK","EXCLUSIONS","Set","DECOMP","RECOMP","has","bucket","get","set","reverse","S0","L0","V0","T0","L_COUNT","V_COUNT","T_COUNT","N_COUNT","S_COUNT","S1","L1","V1","T1","is_hangul","compose_pair","recomp","decomposed","check_order","add","cc","s_index","l_index","v_index","t_index","mapped","pop","prev_cc","tmp","composed_from_decomposed","stack","prev_cp","composed","nfd","nfc","STOP","FE0F","STOP_CH","UNIQUE_PH","HYPHEN","read_set","MAPPED","IGNORED","CM","NSM","ESCAPE","NFC_CHECK","CHUNKS","read_chunked","UNRESTRICTED","GROUPS","R","P","Q","V","sort","M","WHOLE_VALID","WHOLE_MAP","d","values","recs","gs","filter","g","rec","find","G","some","union","complement","multi","VALID","EMOJI_SORTED","EMOJI_ROOT","read_emoji_trie","B","keys","size","temp","F","S","C","Emoji","is_emoji","safe_str_from_cps","quoter","is_combining_mark","should_escape","quoted_cp","bidi_qq","check_label_extension","Error","check_leading_underscore","UNDERSCORE","lastIndexOf","check_fenced","error_placement","last","match","ens_normalize_fragment","frag","decompose","nf","split","label","process","filter_fe0f","ens_normalize","name","flatten","ens_split","ens_beautify","type","output","error","indexOf","preserve_emoji","input","info","norm","tokens","token_count","chars","emoji","every","unique","determine_group","check_group","check_whole","err","group","maker","shared","whole","groups","error_disallowed","error_group_member","msg","message","quoted","gg","where","e","k","consume_emoji_reversed","eaten","node","saved","conform_emoji_copy","copy","from","splice","ens_emoji","build","br","TY_VALID","TY_MAPPED","TY_IGNORED","TY_DISALLOWED","TY_EMOJI","TY_NFC","TY_STOP","ens_tokenize","token","is_valid_or_mapped","requires_check","cps0","tokens0","collapse_valid_tokens"],"sources":["/Users/hamsterpapa/Desktop/ENS/Wallet-browser-extension/mwallet/node_modules/@adraffy/ens-normalize/dist/index.mjs"],"sourcesContent":["function decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r$1 = read_compressed_payload('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');\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r = read_compressed_payload('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');\n\n// https://unicode.org/reports/tr15/\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nconst SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\nconst EXCLUSIONS = new Set(read_sorted(r));\r\nconst DECOMP = new Map();\r\nconst RECOMP = new Map();\r\nfor (let [cp, cps] of read_mapped(r)) {\r\n\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\tlet [a, b] = cps;\r\n\t\tlet bucket = RECOMP.get(a);\r\n\t\tif (!bucket) {\r\n\t\t\tbucket = new Map();\r\n\t\t\tRECOMP.set(a, bucket);\r\n\t\t}\r\n\t\tbucket.set(b, cp);\r\n\t}\r\n\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n}\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\n//const t0 = performance.now();\r\n\r\nconst STOP = 0x2E;\r\nconst FE0F = 0xFE0F;\r\nconst STOP_CH = '.';\r\nconst UNIQUE_PH = 1;\r\nconst HYPHEN = 0x2D;\r\n\r\nfunction read_set() {\r\n\treturn new Set(read_sorted(r$1));\r\n}\r\nconst MAPPED = new Map(read_mapped(r$1)); \r\nconst IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\r\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\r\n// 20230217: we still need all CM for proper error formatting\r\n// but norm only needs NSM subset that are potentially-valid\r\nconst CM = read_set();\r\nconst NSM = new Set(read_sorted(r$1).map(function(i) { return this[i]; }, [...CM]));\r\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/\r\nconst ESCAPE = read_set(); // characters that should not be printed\r\nconst NFC_CHECK = read_set();\r\nconst CHUNKS = read_sorted_arrays(r$1);\r\nfunction read_chunked() {\r\n\t// deduplicated sets + uniques\r\n\treturn new Set([read_sorted(r$1).map(i => CHUNKS[i]), read_sorted(r$1)].flat(2));\r\n}\r\nconst UNRESTRICTED = r$1();\r\nconst GROUPS = read_array_while(i => {\r\n\t// minifier property mangling seems unsafe\r\n\t// so these are manually renamed to single chars\r\n\tlet N = read_array_while(r$1).map(x => x+0x60);\r\n\tif (N.length) {\r\n\t\tlet R = i >= UNRESTRICTED; // first arent restricted\r\n\t\tN[0] -= 32; // capitalize\r\n\t\tN = str_from_cps(N);\r\n\t\tif (R) N=`Restricted[${N}]`;\r\n\t\tlet P = read_chunked(); // primary\r\n\t\tlet Q = read_chunked(); // secondary\r\n\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t//let M = r()-1; // combining mark\r\n\t\tlet M = !r$1(); // not-whitelisted, check for NSM\r\n\t\t// code currently isn't needed\r\n\t\t/*if (M < 0) { // whitelisted\r\n\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\tlet i = r();\r\n\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t})];\r\n\t\t\t}));\r\n\t\t}*/\r\n\t\treturn {N, P, M, R, V: new Set(V)};\r\n\t}\r\n});\r\nconst WHOLE_VALID = read_set();\r\nconst WHOLE_MAP = new Map();\r\n// decode compressed wholes\r\n[...WHOLE_VALID, ...read_set()].sort((a, b) => a-b).map((cp, i, v) => {\r\n\tlet d = r$1(); \r\n\tlet w = v[i] = d ? v[i-d] : {V: [], M: new Map()};\r\n\tw.V.push(cp); // add to member set\r\n\tif (!WHOLE_VALID.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t}\r\n});\r\n// compute confusable-extent complements\r\nfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t// connect all groups that have each whole character\r\n\tlet recs = [];\r\n\tfor (let cp of V) {\r\n\t\tlet gs = GROUPS.filter(g => g.V.has(cp));\r\n\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\tif (!rec) {\r\n\t\t\trec = {G: new Set(), V: []};\r\n\t\t\trecs.push(rec);\r\n\t\t}\r\n\t\trec.V.push(cp);\r\n\t\tgs.forEach(g => rec.G.add(g));\r\n\t}\r\n\t// per character cache groups which are not a member of the extent\r\n\tlet union = recs.flatMap(({G}) => [...G]);\r\n\tfor (let {G, V} of recs) {\r\n\t\tlet complement = new Set(union.filter(g => !G.has(g)));\r\n\t\tfor (let cp of V) {\r\n\t\t\tM.set(cp, complement);\r\n\t\t}\r\n\t}\r\n}\r\nlet union = new Set(); // exists in 1+ groups\r\nlet multi = new Set(); // exists in 2+ groups\r\nfor (let g of GROUPS) {\r\n\tfor (let cp of g.V) {\r\n\t\t(union.has(cp) ? multi : union).add(cp);\r\n\t}\r\n}\r\n// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\nfor (let cp of union) {\r\n\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t}\r\n}\r\nconst VALID = new Set([...union, ...nfd(union)]); // possibly valid\r\n\r\n// decode emoji\r\nconst EMOJI_SORTED = read_sorted(r$1); // temporary\r\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\r\nconst EMOJI_ROOT = read_emoji_trie([]);\r\nfunction read_emoji_trie(cps) {\r\n\tlet B = read_array_while(() => {\r\n\t\tlet keys = read_sorted(r$1).map(i => EMOJI_SORTED[i]);\r\n\t\tif (keys.length) return read_emoji_trie(keys);\r\n\t}).sort((a, b) => b.Q.size - a.Q.size); // sort by likelihood\r\n\tlet temp = r$1();\r\n\tlet V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\r\n\ttemp = (temp / 3)|0;\r\n\tlet F = temp & 1; // allow FE0F\r\n\ttemp >>= 1;\r\n\tlet S = temp & 1; // save\r\n\tlet C = temp & 2; // check\r\n\treturn {B, V, F, S, C, Q: new Set(cps)};\r\n}\r\n//console.log(performance.now() - t0);\r\n\r\n// free tagging system\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; }\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('◌');\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error('invalid label extension');\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\nfunction is_combining_mark(cp) {\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(process(explode_cp(label), nf).flatMap(x => x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(ens_split(name));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet split = ens_split(name, true);\r\n\t// this is experimental\r\n\tfor (let {type, output, error} of split) {\r\n\t\tif (error) continue;\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"‐\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// ξ => Ξ if not greek\r\n\t\tif (type !== 'Greek') { \r\n\t\t\tlet prev = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet next = output.indexOf(0x3BE, prev);\r\n\t\t\t\tif (next < 0) break;\r\n\t\t\t\toutput[next] = 0x39E; \r\n\t\t\t\tprev = next + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(split);\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\tlet norm;\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens[0];\r\n\t\t\t\tlet emoji = token_count > 1 || chars.is_emoji;\r\n\t\t\t\tif (!emoji && chars.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t\tnorm = chars;\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\t// only needed for ascii\r\n\t\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\t\tcheck_label_extension(norm);\r\n\t\t\t\t\t// cant have fenced\r\n\t\t\t\t\t// cant have cm\r\n\t\t\t\t\t// cant have wholes\r\n\t\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\t\ttype = 'ASCII';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (emoji) { // there is at least one emoji\r\n\t\t\t\t\t\tinfo.emoji = true; \r\n\t\t\t\t\t\tchars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnorm = tokens.flatMap(x => !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\t\tlet unique = [...new Set(chars)];\r\n\t\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\tinfo.output = norm;\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = []; // TODO: can this be avoided?\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : [...set];\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaning groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => g.V.has(cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => g.V.has(cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (groups === GROUPS) {\r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp));\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tlet {V, M} = g;\r\n\tfor (let cp of cps) {\r\n\t\tif (!V.has(cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\nfunction process(input, nf) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(emoji);\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps);\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// allows optional FE0F\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet saved;\r\n\tlet stack = [];\r\n\tlet pos = cps.length;\r\n\tif (eaten) eaten.length = 0; // clear input buffer (if needed)\r\n\twhile (pos) {\r\n\t\tlet cp = cps[--pos];\r\n\t\tnode = node.B.find(x => x.Q.has(cp));\r\n\t\tif (!node) break;\r\n\t\tif (node.S) { // remember\r\n\t\t\tsaved = cp;\r\n\t\t} else if (node.C) { // check exclusion\r\n\t\t\tif (cp === saved) break;\r\n\t\t}\r\n\t\tstack.push(cp);\r\n\t\tif (node.F) {\r\n\t\t\tstack.push(FE0F);\r\n\t\t\tif (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\r\n\t\t}\r\n\t\tif (node.V) { // this is a valid emoji (so far)\r\n\t\t\temoji = conform_emoji_copy(stack, node);\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t// *** this code currently isn't needed ***\r\n\tif (!emoji) {\r\n\t\tlet cp = cps[cps.length-1];\r\n\t\tif (EMOJI_SOLO.has(cp)) {\r\n\t\t\tif (eaten) eaten.push(cp);\r\n\t\t\temoji = Emoji.of(cp);\r\n\t\t\tcps.pop();\r\n\t\t}\r\n\t}\r\n\t*/\r\n\treturn emoji;\r\n}\r\n\r\n// create a copy and fix any unicode quirks\r\nfunction conform_emoji_copy(cps, node) {\r\n\tlet copy = Emoji.from(cps); // copy stack\r\n\tif (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\r\n\treturn copy;\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\t// *** this code currently isn't needed ***\r\n\t//let ret = [...EMOJI_SOLO].map(x => [x]);\r\n\tlet ret = [];\r\n\tbuild(EMOJI_ROOT, []);\r\n\treturn ret.sort(compare_arrays);\r\n\tfunction build(node, cps, saved) {\r\n\t\tif (node.S) { \r\n\t\t\tsaved = cps[cps.length-1];\r\n\t\t} else if (node.C) { \r\n\t\t\tif (saved === cps[cps.length-1]) return;\r\n\t\t}\r\n\t\tif (node.F) cps.push(FE0F);\r\n\t\tif (node.V) ret.push(conform_emoji_copy(cps, node));\r\n\t\tfor (let br of node.B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\tbuild(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\t\t\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({type: TY_EMOJI, emoji, input: eaten.slice(), cps: filter_fe0f(emoji)});\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}