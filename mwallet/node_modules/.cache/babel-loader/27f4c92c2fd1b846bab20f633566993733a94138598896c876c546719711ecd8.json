{"ast":null,"code":"import assert from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data) {\n    assert.exists(this);\n    const {\n      view,\n      buffer,\n      blockLen\n    } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out) {\n    assert.exists(this);\n    assert.output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const {\n      buffer,\n      view,\n      blockLen,\n      isLE\n    } = this;\n    let {\n      pos\n    } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const {\n      blockLen,\n      buffer,\n      length,\n      finished,\n      destroyed,\n      pos\n    } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}","map":{"version":3,"names":["assert","Hash","createView","toBytes","setBigUint64","view","byteOffset","value","isLE","_32n","BigInt","_u32_max","wh","Number","wl","h","l","setUint32","SHA2","constructor","blockLen","outputLen","padOffset","finished","length","pos","destroyed","buffer","Uint8Array","update","data","exists","len","take","Math","min","dataView","process","set","subarray","roundClean","digestInto","out","output","fill","i","oview","get","forEach","v","digest","res","slice","destroy","_cloneInto","to"],"sources":["/Users/hamsterpapa/Desktop/ENS/Wallet-browser-extension/mwallet/node_modules/@noble/hashes/esm/_sha2.js"],"sourcesContent":["import assert from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        assert.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        assert.exists(this);\n        assert.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,cAAc;AACjC,SAASC,IAAI,EAAEC,UAAU,EAAEC,OAAO,QAAQ,YAAY;AACtD;AACA,SAASC,YAAYA,CAACC,IAAI,EAAEC,UAAU,EAAEC,KAAK,EAAEC,IAAI,EAAE;EACjD,IAAI,OAAOH,IAAI,CAACD,YAAY,KAAK,UAAU,EACvC,OAAOC,IAAI,CAACD,YAAY,CAACE,UAAU,EAAEC,KAAK,EAAEC,IAAI,CAAC;EACrD,MAAMC,IAAI,GAAGC,MAAM,CAAC,EAAE,CAAC;EACvB,MAAMC,QAAQ,GAAGD,MAAM,CAAC,UAAU,CAAC;EACnC,MAAME,EAAE,GAAGC,MAAM,CAAEN,KAAK,IAAIE,IAAI,GAAIE,QAAQ,CAAC;EAC7C,MAAMG,EAAE,GAAGD,MAAM,CAACN,KAAK,GAAGI,QAAQ,CAAC;EACnC,MAAMI,CAAC,GAAGP,IAAI,GAAG,CAAC,GAAG,CAAC;EACtB,MAAMQ,CAAC,GAAGR,IAAI,GAAG,CAAC,GAAG,CAAC;EACtBH,IAAI,CAACY,SAAS,CAACX,UAAU,GAAGS,CAAC,EAAEH,EAAE,EAAEJ,IAAI,CAAC;EACxCH,IAAI,CAACY,SAAS,CAACX,UAAU,GAAGU,CAAC,EAAEF,EAAE,EAAEN,IAAI,CAAC;AAC5C;AACA;AACA,OAAO,MAAMU,IAAI,SAASjB,IAAI,CAAC;EAC3BkB,WAAWA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,SAAS,EAAEd,IAAI,EAAE;IAC9C,KAAK,CAAC,CAAC;IACP,IAAI,CAACY,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACd,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACe,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,GAAG,GAAG,CAAC;IACZ,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,MAAM,GAAG,IAAIC,UAAU,CAACR,QAAQ,CAAC;IACtC,IAAI,CAACf,IAAI,GAAGH,UAAU,CAAC,IAAI,CAACyB,MAAM,CAAC;EACvC;EACAE,MAAMA,CAACC,IAAI,EAAE;IACT9B,MAAM,CAAC+B,MAAM,CAAC,IAAI,CAAC;IACnB,MAAM;MAAE1B,IAAI;MAAEsB,MAAM;MAAEP;IAAS,CAAC,GAAG,IAAI;IACvCU,IAAI,GAAG3B,OAAO,CAAC2B,IAAI,CAAC;IACpB,MAAME,GAAG,GAAGF,IAAI,CAACN,MAAM;IACvB,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGO,GAAG,GAAG;MAC1B,MAAMC,IAAI,GAAGC,IAAI,CAACC,GAAG,CAACf,QAAQ,GAAG,IAAI,CAACK,GAAG,EAAEO,GAAG,GAAGP,GAAG,CAAC;MACrD;MACA,IAAIQ,IAAI,KAAKb,QAAQ,EAAE;QACnB,MAAMgB,QAAQ,GAAGlC,UAAU,CAAC4B,IAAI,CAAC;QACjC,OAAOV,QAAQ,IAAIY,GAAG,GAAGP,GAAG,EAAEA,GAAG,IAAIL,QAAQ,EACzC,IAAI,CAACiB,OAAO,CAACD,QAAQ,EAAEX,GAAG,CAAC;QAC/B;MACJ;MACAE,MAAM,CAACW,GAAG,CAACR,IAAI,CAACS,QAAQ,CAACd,GAAG,EAAEA,GAAG,GAAGQ,IAAI,CAAC,EAAE,IAAI,CAACR,GAAG,CAAC;MACpD,IAAI,CAACA,GAAG,IAAIQ,IAAI;MAChBR,GAAG,IAAIQ,IAAI;MACX,IAAI,IAAI,CAACR,GAAG,KAAKL,QAAQ,EAAE;QACvB,IAAI,CAACiB,OAAO,CAAChC,IAAI,EAAE,CAAC,CAAC;QACrB,IAAI,CAACoB,GAAG,GAAG,CAAC;MAChB;IACJ;IACA,IAAI,CAACD,MAAM,IAAIM,IAAI,CAACN,MAAM;IAC1B,IAAI,CAACgB,UAAU,CAAC,CAAC;IACjB,OAAO,IAAI;EACf;EACAC,UAAUA,CAACC,GAAG,EAAE;IACZ1C,MAAM,CAAC+B,MAAM,CAAC,IAAI,CAAC;IACnB/B,MAAM,CAAC2C,MAAM,CAACD,GAAG,EAAE,IAAI,CAAC;IACxB,IAAI,CAACnB,QAAQ,GAAG,IAAI;IACpB;IACA;IACA;IACA,MAAM;MAAEI,MAAM;MAAEtB,IAAI;MAAEe,QAAQ;MAAEZ;IAAK,CAAC,GAAG,IAAI;IAC7C,IAAI;MAAEiB;IAAI,CAAC,GAAG,IAAI;IAClB;IACAE,MAAM,CAACF,GAAG,EAAE,CAAC,GAAG,UAAU;IAC1B,IAAI,CAACE,MAAM,CAACY,QAAQ,CAACd,GAAG,CAAC,CAACmB,IAAI,CAAC,CAAC,CAAC;IACjC;IACA,IAAI,IAAI,CAACtB,SAAS,GAAGF,QAAQ,GAAGK,GAAG,EAAE;MACjC,IAAI,CAACY,OAAO,CAAChC,IAAI,EAAE,CAAC,CAAC;MACrBoB,GAAG,GAAG,CAAC;IACX;IACA;IACA,KAAK,IAAIoB,CAAC,GAAGpB,GAAG,EAAEoB,CAAC,GAAGzB,QAAQ,EAAEyB,CAAC,EAAE,EAC/BlB,MAAM,CAACkB,CAAC,CAAC,GAAG,CAAC;IACjB;IACA;IACA;IACAzC,YAAY,CAACC,IAAI,EAAEe,QAAQ,GAAG,CAAC,EAAEV,MAAM,CAAC,IAAI,CAACc,MAAM,GAAG,CAAC,CAAC,EAAEhB,IAAI,CAAC;IAC/D,IAAI,CAAC6B,OAAO,CAAChC,IAAI,EAAE,CAAC,CAAC;IACrB,MAAMyC,KAAK,GAAG5C,UAAU,CAACwC,GAAG,CAAC;IAC7B,IAAI,CAACK,GAAG,CAAC,CAAC,CAACC,OAAO,CAAC,CAACC,CAAC,EAAEJ,CAAC,KAAKC,KAAK,CAAC7B,SAAS,CAAC,CAAC,GAAG4B,CAAC,EAAEI,CAAC,EAAEzC,IAAI,CAAC,CAAC;EACjE;EACA0C,MAAMA,CAAA,EAAG;IACL,MAAM;MAAEvB,MAAM;MAAEN;IAAU,CAAC,GAAG,IAAI;IAClC,IAAI,CAACoB,UAAU,CAACd,MAAM,CAAC;IACvB,MAAMwB,GAAG,GAAGxB,MAAM,CAACyB,KAAK,CAAC,CAAC,EAAE/B,SAAS,CAAC;IACtC,IAAI,CAACgC,OAAO,CAAC,CAAC;IACd,OAAOF,GAAG;EACd;EACAG,UAAUA,CAACC,EAAE,EAAE;IACXA,EAAE,KAAKA,EAAE,GAAG,IAAI,IAAI,CAACpC,WAAW,CAAC,CAAC,CAAC;IACnCoC,EAAE,CAACjB,GAAG,CAAC,GAAG,IAAI,CAACS,GAAG,CAAC,CAAC,CAAC;IACrB,MAAM;MAAE3B,QAAQ;MAAEO,MAAM;MAAEH,MAAM;MAAED,QAAQ;MAAEG,SAAS;MAAED;IAAI,CAAC,GAAG,IAAI;IACnE8B,EAAE,CAAC/B,MAAM,GAAGA,MAAM;IAClB+B,EAAE,CAAC9B,GAAG,GAAGA,GAAG;IACZ8B,EAAE,CAAChC,QAAQ,GAAGA,QAAQ;IACtBgC,EAAE,CAAC7B,SAAS,GAAGA,SAAS;IACxB,IAAIF,MAAM,GAAGJ,QAAQ,EACjBmC,EAAE,CAAC5B,MAAM,CAACW,GAAG,CAACX,MAAM,CAAC;IACzB,OAAO4B,EAAE;EACb;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}